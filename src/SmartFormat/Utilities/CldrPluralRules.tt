<#@ template language="C#" hostspecific="true" debug="true" 
#><#@ assembly name="System.Core" 
#><#@ assembly name="System.Text.Json" 
#><#@ import namespace="System" 
#><#@ import namespace="System.IO" 
#><#@ assembly name="System.Memory" 
#><#@ import namespace="System.Text.Json" 
#><#@ import namespace="System.Text.Json.Serialization" 
#><#@ import namespace="System.Text.RegularExpressions" 
#><#@ import namespace="System.Collections.Generic" 
#><#@ import namespace="System.Globalization" 
#><#@ import namespace="System.Linq" 
#><#
    // Download the CLDR JSON data file from: https://github.com/unicode-org/cldr-json
    var inputFile = Host.ResolvePath("plurals.json");
    if (!File.Exists(inputFile))
    {
        throw new FileNotFoundException($"CLDR data file not found: {inputFile}");
    }
    
    // Process the CLDR data
    var jsonContent = File.ReadAllText(inputFile);
    var cldrData = JsonSerializer.Deserialize<CldrRoot>(jsonContent);

    if (cldrData?.Supplemental.PluralsTypeCardinal == null)
    {
        throw new InvalidOperationException("Failed to parse 'plurals-type-cardinal' data from JSON.");
    }

    // Process rules for each language
    var langToRuleSet = cldrData.Supplemental.PluralsTypeCardinal
        .ToDictionary(kvp => kvp.Key, kvp => new LanguageRuleSet(kvp.Value));

    var rulesToLangs = langToRuleSet
        .GroupBy(kvp => kvp.Value.CanonicalKey)
        .ToDictionary(g => g.Key, g => g.Select(kvp => kvp.Key).ToList());

    var ruleMethodNames = new Dictionary<string, string>();
    var ruleIndex = 0;
    foreach (var key in rulesToLangs.Keys.OrderBy(k => rulesToLangs[k].First()))
    {
        var ruleSet = langToRuleSet[rulesToLangs[key].First()];
        var methodName = ruleSet.Rules.Count == 0 ? "Singular" : $"Rule{++ruleIndex}";
        ruleMethodNames[key] = methodName;
    }

#>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: <#= Environment.Version.ToString() #>
//
//     Unicode Version: <#= cldrData.Supplemental.Version.UniCodeVersion #>
//     CLDR Version: <#= cldrData.Supplemental.Version.Release #>
//     Generation date: <#= DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss") #> UTC
//
//     Changes to this file may cause incorrect behavior 
//     and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;

namespace SmartFormat.Utilities;

/// <summary>
/// The pluralization category of a number, as defined by the Unicode CLDR.
/// </summary>
internal enum PluralCategory
{
    Zero,
    One,
    Two,
    Few,
    Many,
    Other
}

internal sealed class CldrPluralRule
{
    public IReadOnlyList<PluralCategory> PossibleCategories { get; }
    public CldrPluralRules.PluralRuleDelegate Delegate { get; }

    public CldrPluralRule(IEnumerable<PluralCategory> possibleCategories, CldrPluralRules.PluralRuleDelegate ruleDelegate)
    {
        PossibleCategories = possibleCategories.ToArray();
        Delegate = ruleDelegate;
    }

    public PluralCategory GetCategory(decimal value)
    {
        return Delegate(value);
    }
}

/// <summary>
/// Provides functionality for determining plural categories based
/// on the CLDR (Common Locale Data Repository) pluralization rules.
/// <para/>
/// Download the CLDR JSON data file from: https://github.com/unicode-org/cldr-json
/// </summary>
/// <remarks>This class contains a collection of predefined pluralization
/// rules for various languages, as defined by the CLDR.
/// It allows developers to retrieve and apply the appropriate pluralization
/// rule for a given language, based on its ISO language code.
/// </remarks>
internal static class CldrPluralRules
{
    #region Plural Rule Delegates

    // For languages with a single form (e.g., Japanese, Chinese, Vietnamese), the category is 'other'.
    private static PluralCategory Singular(decimal value) => PluralCategory.Other;

<# foreach (var kvp in rulesToLangs.OrderBy(kvp => kvp.Value.First())) 
{
    var key = kvp.Key;
    var langs = kvp.Value;
    var methodName = ruleMethodNames[key];
    if (methodName == "Singular") continue;

    var ruleSet = langToRuleSet[langs.First()];
    var titleCase = CultureInfo.InvariantCulture.TextInfo;
#>
    // Rule for: <#= string.Join(", ", langs.Take(5)) #><#= langs.Count > 5 ? ", ..." : "" #>
    private static PluralCategory <#= methodName #>(decimal value)
    {
        var (n, i, v, w, f, t, e) = GetOperands(value);
<# foreach (var rule in ruleSet.Rules) { 
    var csharpRule = TranslateRuleToCSharp(rule.OriginalRule);
    var enumValue = $"PluralCategory.{titleCase.ToTitleCase(rule.Category)}";

#>        if (<#= csharpRule #>) return <#= enumValue #>;
<# } #>
        return PluralCategory.Other;
    }

<# } #>
    #endregion

    private static readonly Dictionary<string, CldrPluralRule> DefaultLangToRule = new()
    {
<# foreach (var lang in rulesToLangs.SelectMany(kvp => kvp.Value).OrderBy(l => l)) {
    var ruleSet = langToRuleSet[lang];
    var methodName = ruleMethodNames[ruleSet.CanonicalKey];
    var categories = ruleSet.Rules.Select(r => r.Category).ToList();
    categories.Add("other");
    var categoryArrayString = $"new[] {{ {string.Join(", ", categories.Select(c => $"PluralCategory.{CultureInfo.InvariantCulture.TextInfo.ToTitleCase(c)}"))} }}";
#>        { "<#= lang #>", new CldrPluralRule(<#= categoryArrayString #>, <#= methodName #>) },
<# } #>
    };

    public static Dictionary<string, CldrPluralRule> IsoCodeToRule { get; private set; } = new(DefaultLangToRule);

    public static void RestoreDefault() => IsoCodeToRule = new Dictionary<string, CldrPluralRule>(DefaultLangToRule);

    internal delegate PluralCategory PluralRuleDelegate(decimal value);
        
    public static CldrPluralRule GetPluralRule(string? twoLetterIsoCode)
    {
        if (twoLetterIsoCode != null && IsoCodeToRule.TryGetValue(twoLetterIsoCode, out var rule))
            return rule;
        
        return IsoCodeToRule["und"];
    }

    #region CLDR Helper methods

    /// <summary>
    /// n => The absolute value of the input number (e.g., 1, 2.5, 0.01)
    /// u => The integer digits of n (deprecated in CLDR, but may appear in legacy rules)
    /// v => Number of visible fraction digits in n (e.g., 1.5 => v = 1)
    /// w => Number of visible fraction digits excluding trailing zeros (e.g., 1.50 => w = 1)
    /// f => Visible fraction digits as an integer (e.g., 1.25 => f = 25)
    /// t => Visible fraction digits excluding trailing zeros (e.g., 1.50 => t = 5) 
    /// e => Always 0 for decimal input
    /// </summary>
    private static (decimal n, long i, int v, int w, long f, long t, int e) GetOperands(decimal value)
    {
        // Get absolute value for CLDR rules
        var n = Math.Abs(value);
    
        // GetBits() returns an array of four integers.
        // Extract the binary representation of the decimal:
        // decimals are stored as 96-bit integer with a scaling factor.
        // - bits[0], bits[1], bits[2] form the 96-bit integer value
        // - bits[3] contains the scale (bits 16-23) and sign (bit 31)
        var bits = decimal.GetBits(n);
    
        // Integer part (before decimal point)
        var i = (long) Math.Truncate(n);
    
        // v = number of visible fractional digits (including trailing zeros)
        // w = number of significant fractional digits (excluding trailing zeros)  
        // f = fractional digits as integer (with trailing zeros)
        // t = fractional digits as integer (without trailing zeros)
        // e = exponent (used for scientific notation)
        //     Only numbers like 1.0e6 should have e != 0
        //     Since we're parsing from regular decimal, e is always 0
        int v = 0, w = 0, e = 0;
        long f = 0, t = 0;

        // Extract scale factor - to see how many fractional digits exist
        // Move scale to the lowest 8 bits and filter lower 5 bits (0-28)
        var scale = (bits[3] >> 16) & 0x1F;
    
        if (scale > 0)
        {
            // Total visible fractional digits (v) equals the scale
            v = scale;
        
            // Calculate fractional part mathematically
            var fractionalPart = n - i;
            f = (long) (fractionalPart * Pow10(scale));
        
            // Remove trailing zeros for significant fractional digits (w)
            var temp = f;
            w = scale;
            while (temp % 10 == 0 && temp > 0)
            {
                temp /= 10;
                w--;
            }
            t = temp;
        }

        return (n, i, v, w, f, t, e);
    }

    private static decimal Pow10(int exponent) => (decimal) Math.Pow(10, exponent);

    private static bool IsInRange(long val, long min, long max) => val >= min && val <= max;
    
    private static bool IsInRange(decimal val, decimal min, decimal max)
    {
        // First check if value is within the range
        if (val < min || val > max)
            return false;

        // If min and max are integers (whole numbers), then require val to also be integer
        // This for rules like 'n = 2..4' which should not match '2.5'
        if (min == Math.Truncate(min) && max == Math.Truncate(max))
        {
            return val == Math.Truncate(val);
        }

        return true;
    }

    #endregion
}
<#+
    private class CldrRoot
    {
        [JsonPropertyName("supplemental")] 
        public CldrSupplemental Supplemental { get; set; } = new();
    }

	private class CldrVersion
	{
		[JsonPropertyName("_unicodeVersion")]
		public string UniCodeVersion { get; set; } = string.Empty;

		[JsonPropertyName("_cldrVersion")]
		public string Release { get; set; } = string.Empty;
	}

    private class CldrSupplemental
    {
		[JsonPropertyName("version")]
		public CldrVersion Version { get; set; } = new();

        [JsonPropertyName("plurals-type-cardinal")]
        public Dictionary<string, Dictionary<string, string>> PluralsTypeCardinal { get; set; } = new();
    }

    private class LanguageRuleSet
    {
        public List<Rule> Rules { get; }
        public string CanonicalKey { get; }
        private static readonly string[] CategoryOrder = { "zero", "one", "two", "few", "many", "other" };

        public LanguageRuleSet(IReadOnlyDictionary<string, string> rawRules)
        {
            Rules = new List<Rule>();
            var sortedCategories = rawRules.Keys
                .Select(k => k.Replace("pluralRule-count-", ""))
                .OrderBy(cat => Array.IndexOf(CategoryOrder, cat));

            foreach (var category in sortedCategories)
            {
                if (category == "other") continue;
                var rawRule = rawRules[$"pluralRule-count-{category}"].Split('@')[0].Trim();
                if (!string.IsNullOrEmpty(rawRule))
                {
                    Rules.Add(new Rule(category, rawRule));
                }
            }
            CanonicalKey = string.Join(";", Rules.Select(r => $"{r.Category}:{r.OriginalRule}"));
        }
    }

    private class Rule
    {
        public string Category { get; }
        public string OriginalRule { get; }

        public Rule(string category, string originalRule)
        {
            Category = category;
            OriginalRule = originalRule;
        }
    }

	internal static readonly char[] CommaSeparator = { ',' };
	
    internal static readonly string[] OrSeparator = { " or " };

	internal static readonly string[] AndSeparator = { " and " };

    internal static string TranslateRuleToCSharp(string cldrRule)
    {
        var rule = Regex.Replace(cldrRule, @"\s+", " ").Trim();

        var orParts = rule.Split(OrSeparator, StringSplitOptions.None);
        var finalOrParts = new List<string>();

        foreach (var orPart in orParts)
        {
            var andParts = orPart.Split(AndSeparator, StringSplitOptions.None);
            var finalAndParts = new List<string>();
            foreach (var andPart in andParts)
            {
                var part = andPart.Trim();

                // Match for list/range expressions: 'operand' followed by '!=', '=', 
                // and then any sequence of digits, commas, dots, and spaces.
                var listRangeMatch = Regex.Match(part, @"(.+?)\s*(!=|=)\s*([\d,\.\s]+)");

	            // Process this as a complex list/range if it contains a comma (list) or a range (..)
                if (listRangeMatch.Success && (listRangeMatch.Groups[3].Value.Contains(',') || listRangeMatch.Groups[3].Value.Contains("..")))
                {
                    var operand = listRangeMatch.Groups[1].Value.Trim();
                    var opSymbol = listRangeMatch.Groups[2].Value; // = or !=
                    var valueListStr = listRangeMatch.Groups[3].Value.Replace(" ", "");

                    var opNegation = opSymbol == "!=" ? "!" : ""; // C# negation prefix
                    var items = valueListStr.Split(CommaSeparator, StringSplitOptions.RemoveEmptyEntries);
                    var itemChecks = new List<string>();

                    // Logic to process a single item (a value or a range)
                    // Build the list of checks for each value/range (connected by ||)
                    foreach (var item in items)
                    {
                        itemChecks.Add(ProcessItem(item, operand));
                    }

                    // Combine all checks with " || " for the inclusion list
                    var combinedChecks = itemChecks.Count > 1
                        ? $"({string.Join(" || ", itemChecks)})"
                        : itemChecks[0];

                    // Add the result with the correct negation (if '!=')
                    finalAndParts.Add($"{opNegation}{combinedChecks}");
                    continue;
                }

	            // This is the fallback for simple relational expressions:
	            // "n != 0", "n = 0", "n < 10"

	            // Convert CLDR equality '=' to C# equality '=='
	            // This regex ignores '!=', '>=', '<=' to keep intact
	            part = Regex.Replace(part, @"(?<![<>!])=", " == ");

	            finalAndParts.Add(part);
            }

            finalOrParts.Add(finalAndParts.Count > 1 ? $"({string.Join(" && ", finalAndParts)})" : finalAndParts[0]);
        }
        return finalOrParts.Count > 1 ? $"({string.Join(" || ", finalOrParts)})" : finalOrParts[0];
    }

	// Logic to process a single item (a value or a range)
	private static string ProcessItem(string item, string operand)
	{
		// n is decimal, others are int or long
		var isDecimal = operand.FirstOrDefault(o => o == 'n') == 'n';
		var suffix = isDecimal ? "m" : string.Empty;

		var rangeParts = item.Split(new[] { ".." }, StringSplitOptions.None);
		if (rangeParts.Length == 2)
		{
			// It's a range: min..max
			var min = rangeParts[0];
			var max = rangeParts[1];
			return $"IsInRange({operand}, {min}{suffix}, {max}{suffix})";
		}

		// It's a single value: e.g., '9'
		return $"{operand} == {item}{suffix}";
	}
#>