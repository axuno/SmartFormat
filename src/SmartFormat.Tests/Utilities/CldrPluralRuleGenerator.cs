#if NET6_0_OR_GREATER
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json.Serialization;
using System.Text.RegularExpressions;
using System.Text.Json;

namespace SmartFormat.Tests.Utilities;

// This is the prototype code used to generate CldrPluralRules.cs
// CldrPluralRules.tt is the T4 template that now creates CldrPluralRules.cs
// It is not included in the build, but kept here for reference.
[ExcludeFromCodeCoverage]
internal static class CldrPluralRuleGenerator
{
    #region JSON Deserialization DTOs

    private class CldrRoot
    {
        [JsonPropertyName("supplemental")] public CldrSupplemental Supplemental { get; set; } = new();
    }

    private class CldrVersion
    {
        [JsonPropertyName("_unicodeVersion")]
        public string UniCodeVersion { get; set; } = string.Empty;

        [JsonPropertyName("_cldrVersion")]
        public string Release { get; set; } = string.Empty;
    }

    private class CldrSupplemental
    {
        [JsonPropertyName("version")]
        public CldrVersion Version { get; set; } = new();

        [JsonPropertyName("plurals-type-cardinal")]
        public Dictionary<string, Dictionary<string, string>> PluralsTypeCardinal { get; set; } = new();
    }

    #endregion

    #region Rule Processing Classes

    private class LanguageRuleSet
    {
        public List<Rule> Rules { get; } = [];
        public string CanonicalKey { get; }
        private static readonly string[] CategoryOrder = ["zero", "one", "two", "few", "many", "other"];

        public LanguageRuleSet(IReadOnlyDictionary<string, string> rawRules)
        {
            var sortedCategories = rawRules.Keys
                .Select(k => k.Replace("pluralRule-count-", ""))
                .OrderBy(cat => Array.IndexOf(CategoryOrder, cat));

            foreach (var category in sortedCategories)
            {
                if (category == "other") continue;
                var rawRule = rawRules[$"pluralRule-count-{category}"].Split('@')[0].Trim();
                if (!string.IsNullOrEmpty(rawRule))
                {
                    Rules.Add(new Rule(category, rawRule));
                }
            }

            CanonicalKey = string.Join(";", Rules.Select(r => $"{r.Category}:{r.OriginalRule}"));
        }
    }

    private class Rule
    {
        public string Category { get; }
        public string OriginalRule { get; }

        public Rule(string category, string originalRule)
        {
            Category = category;
            OriginalRule = originalRule;
        }
    }

    #endregion

    // Download the CLDR JSON data file from: https://github.com/unicode-org/cldr-json
    public static void Generate(string inputFile, string outputFile)
    {
        if (!File.Exists(inputFile))
        {
            Console.WriteLine($"Error: Input file not found: {Path.GetFullPath(inputFile)}");
            return;
        }

        Console.WriteLine($"Reading CLDR plural rules from '{inputFile}'...");
        var jsonContent = File.ReadAllText(inputFile);
        var cldrData = JsonSerializer.Deserialize<CldrRoot>(jsonContent);

        if (cldrData?.Supplemental.PluralsTypeCardinal == null)
        {
            Console.WriteLine("Error: Failed to parse 'plurals-type-cardinal' data from JSON.");
            return;
        }

        Console.WriteLine("Processing rules for each language...");
        var langToRuleSet = cldrData.Supplemental.PluralsTypeCardinal
            .ToDictionary(kvp => kvp.Key, kvp => new LanguageRuleSet(kvp.Value));

        var rulesToLangs = langToRuleSet
            .GroupBy(kvp => kvp.Value.CanonicalKey)
            .ToDictionary(g => g.Key, g => g.Select(kvp => kvp.Key).ToList());

        Console.WriteLine($"Generating '{outputFile}'...");
        var sb = new StringBuilder();

        // Add header
        sb.AppendLine("//");
        sb.AppendLine($"// AUTO-GENERATED BY {nameof(CldrPluralRuleGenerator)}");
        sb.AppendLine($"// Unicode Version: {cldrData.Supplemental.Version.UniCodeVersion}");
        sb.AppendLine($"// CLDR Version: {cldrData.Supplemental.Version.Release}");
        sb.AppendLine($"// Generation date: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
        sb.AppendLine("//");

        GenerateCSharpCode(sb, rulesToLangs, langToRuleSet);

        File.WriteAllText(outputFile, sb.ToString(), Encoding.UTF8);
        Console.WriteLine(
            $"Successfully generated '{outputFile}'. Found {rulesToLangs.Count} unique pluralization rule sets across {langToRuleSet.Count} languages.");
    }

    internal static readonly char[] CommaSeparator = { ',' };

    internal static readonly string[] OrSeparator = { " or " };

    internal static readonly string[] AndSeparator = { " and " };

    internal static string TranslateRuleToCSharp(string cldrRule)
    {
        var rule = Regex.Replace(cldrRule, @"\s+", " ").Trim();

        var orParts = rule.Split(OrSeparator, StringSplitOptions.None);
        var finalOrParts = new List<string>();

        foreach (var orPart in orParts)
        {
            var andParts = orPart.Split(AndSeparator, StringSplitOptions.None);
            var finalAndParts = new List<string>();
            foreach (var andPart in andParts)
            {
                var part = andPart.Trim();

                // Match for list/range expressions: 'operand' followed by '!=', '=', 
                // and then any sequence of digits, commas, dots, and spaces.
                var listRangeMatch = Regex.Match(part, @"(.+?)\s*(!=|=)\s*([\d,\.\s]+)");

                // Process this as a complex list/range if it contains a comma (list) or a range (..)
                if (listRangeMatch.Success && (listRangeMatch.Groups[3].Value.Contains(',') ||
                                               listRangeMatch.Groups[3].Value.Contains("..")))
                {
                    var operand = listRangeMatch.Groups[1].Value.Trim();
                    var opSymbol = listRangeMatch.Groups[2].Value; // = or !=
                    var valueListStr = listRangeMatch.Groups[3].Value.Replace(" ", "");

                    var opNegation = opSymbol == "!=" ? "!" : ""; // C# negation prefix
                    var items = valueListStr.Split(CommaSeparator, StringSplitOptions.RemoveEmptyEntries);
                    var itemChecks = new List<string>();

                    // Logic to process a single item (a value or a range)
                    // Build the list of checks for each value/range (connected by ||)
                    foreach (var item in items)
                    {
                        itemChecks.Add(ProcessItem(item, operand));
                    }

                    // Combine all checks with " || " for the inclusion list
                    var combinedChecks = itemChecks.Count > 1
                        ? $"({string.Join(" || ", itemChecks)})"
                        : itemChecks[0];

                    // Add the result with the correct negation (if '!=')
                    finalAndParts.Add($"{opNegation}{combinedChecks}");
                    continue;
                }

                // This is the fallback for simple relational expressions:
                // "n != 0", "n = 0", "n < 10"

                // Convert CLDR equality '=' to C# equality '=='
                // This regex ignores '!=', '>=', '<=' to keep intact
                part = Regex.Replace(part, @"(?<![<>!])=", " == ");

                finalAndParts.Add(part);
            }

            finalOrParts.Add(finalAndParts.Count > 1 ? $"({string.Join(" && ", finalAndParts)})" : finalAndParts[0]);
        }

        return finalOrParts.Count > 1 ? $"({string.Join(" || ", finalOrParts)})" : finalOrParts[0];
    }

    // Logic to process a single item (a value or a range)
    private static string ProcessItem(string item, string operand)
    {
        // n is decimal, others are int or long
        var isDecimal = operand.FirstOrDefault(o => o == 'n') == 'n';
        var suffix = isDecimal ? "m" : string.Empty;

        var rangeParts = item.Split(new[] { ".." }, StringSplitOptions.None);
        if (rangeParts.Length == 2)
        {
            // It's a range: min..max
            var min = rangeParts[0];
            var max = rangeParts[1];
            return $"IsInRange({operand}, {min}{suffix}, {max}{suffix})";
        }

        // It's a single value: e.g., '9'
        return $"{operand} == {item}{suffix}";
    }

    private static void GenerateCSharpCode(StringBuilder sb, Dictionary<string, List<string>> rulesToLangs,
        Dictionary<string, LanguageRuleSet> langToRuleSet)
    {
        var ruleMethodNames = new Dictionary<string, string>();
        var ruleIndex = 0;
        foreach (var key in rulesToLangs.Keys.OrderBy(k => rulesToLangs[k].First()))
        {
            var ruleSet = langToRuleSet[rulesToLangs[key].First()];
            var methodName = ruleSet.Rules.Count == 0 ? "Singular" : $"Rule{++ruleIndex}";
            ruleMethodNames[key] = methodName;
        }

        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Globalization;");
        sb.AppendLine();
        sb.AppendLine("namespace SmartFormat.Utilities;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// The pluralization category of a number, as defined by the Unicode CLDR.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public enum PluralCategory");
        sb.AppendLine("{");
        sb.AppendLine("    Zero,");
        sb.AppendLine("    One,");
        sb.AppendLine("    Two,");
        sb.AppendLine("    Few,");
        sb.AppendLine("    Many,");
        sb.AppendLine("    Other");
        sb.AppendLine("}");
        sb.AppendLine();
        sb.Append("""
                  /// <summary>
                  /// Provides functionality for determining plural categories based
                  /// on the CLDR (Common Locale Data Repository) pluralization rules.
                  /// <para/>
                  /// Download the CLDR JSON data file from: https://github.com/unicode-org/cldr-json
                  /// </summary>
                  /// <remarks>This class contains a collection of predefined pluralization
                  /// rules for various languages, as defined by the CLDR.
                  /// It allows developers to retrieve and apply the appropriate pluralization
                  /// rule for a given language, based on its ISO language code.
                  /// </remarks>
                  public static class CldrPluralRules
                  {

                  """);
        sb.AppendLine("    #region Plural Rule Delegates");
        sb.AppendLine();
        sb.AppendLine(
            "    // For languages with a single form (e.g., Japanese, Chinese, Vietnamese), the category is 'other'.");
        sb.AppendLine(
            "    private static PluralCategory Singular(decimal value, int pluralWordsCount) => PluralCategory.Other;");
        sb.AppendLine();
        foreach (var (key, langs) in rulesToLangs.OrderBy(kvp => kvp.Value.First()))
        {
            var methodName = ruleMethodNames[key];
            if (methodName == "Singular") continue;

            var ruleSet = langToRuleSet[langs.First()];
            var titleCase = CultureInfo.InvariantCulture.TextInfo;
            sb.AppendLine($"    // Rule for: {string.Join(", ", langs.Take(5))}{(langs.Count > 5 ? ", ..." : "")}");
            sb.AppendLine($"    private static PluralCategory {methodName}(decimal value, int pluralWordsCount)");
            sb.AppendLine("    {");
            sb.AppendLine("        var (n, i, v, w, f, t, e) = GetOperands(value);");

            foreach (var rule in ruleSet.Rules)
            {
                var csharpRule = TranslateRuleToCSharp(rule.OriginalRule);
                var enumValue = $"PluralCategory.{titleCase.ToTitleCase(rule.Category)}";
                sb.AppendLine($"        if ({csharpRule}) return {enumValue};");
            }

            sb.AppendLine("        return PluralCategory.Other;");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        sb.AppendLine("    #endregion");
        sb.AppendLine();

        sb.AppendLine(
            "    private static readonly Dictionary<string, PluralRuleDelegate> DefaultLangToDelegate = new()");
        sb.AppendLine("    {");

        foreach (var lang in rulesToLangs.SelectMany(kvp => kvp.Value).OrderBy(l => l))
        {
            var ruleSet = langToRuleSet[lang];
            var methodName = ruleMethodNames[ruleSet.CanonicalKey];
            var categories = ruleSet.Rules.Select(r => r.Category).ToList();
            categories.Add("other");
            var comment = string.Join(", ", categories);
            sb.AppendLine($"        {{ \"{lang}\", {methodName} }}, // {comment}");
        }

        sb.AppendLine("    };");
        sb.AppendLine();

        sb.AppendLine(
            @"    public static Dictionary<string, PluralRuleDelegate> IsoLangToDelegate { get; private set; } = new(DefaultLangToDelegate);

    public static void RestoreDefault() => IsoLangToDelegate = new Dictionary<string, PluralRuleDelegate>(DefaultLangToDelegate);

    public delegate PluralCategory PluralRuleDelegate(decimal value, int pluralWordsCount);
        
    public static PluralRuleDelegate GetPluralRule(string? twoLetterIsoLanguageName)
    {
        if (twoLetterIsoLanguageName != null && IsoLangToDelegate.TryGetValue(twoLetterIsoLanguageName, out var rule))
            return rule;
        
        return IsoLangToDelegate[""und""];
    }

    #region CLDR Helper methods

    /// <summary>
    /// n => The absolute value of the input number (e.g., 1, 2.5, 0.01)
    /// u => The integer digits of n (deprecated in CLDR, but may appear in legacy rules)
    /// v => Number of visible fraction digits in n (e.g., 1.5 => v = 1)
    /// w => Number of visible fraction digits excluding trailing zeros (e.g., 1.50 => w = 1)
    /// f => Visible fraction digits as an integer (e.g., 1.25 => f = 25)
    /// t => Visible fraction digits excluding trailing zeros (e.g., 1.50 => t = 5) 
    /// </summary>
    private static (decimal n, long i, int v, int w, long f, long t, int e) GetOperands(decimal value)
    {
        var n = Math.Abs(value);
        var s = value.ToString(CultureInfo.InvariantCulture);
        long i = (long)Math.Truncate(n);
        int v = 0, w = 0, e = 0;
        long f = 0, t = 0;

        var decPoint = s.IndexOf('.');
        if (decPoint != -1)
        {
            var fractionStr = s.Substring(decPoint + 1);
            v = fractionStr.Length;
            long.TryParse(fractionStr, NumberStyles.Integer, CultureInfo.InvariantCulture, out f);

            var fractionStrTrimmed = fractionStr.TrimEnd('0');
            w = fractionStrTrimmed.Length;
            long.TryParse(fractionStrTrimmed, NumberStyles.Integer, CultureInfo.InvariantCulture, out t);
        }

        return (n, i, v, w, f, t, e);
    }

    private static bool IsInRange(long val, long min, long max) => val >= min && val <= max;
    
    private static bool IsInRange(decimal val, decimal min, decimal max)
    {
        // First check if value is within the range
        if (val < min || val > max)
            return false;

        // If min and max are integers (whole numbers), then require val to also be integer
        // This for rules like 'n = 2..4' which should not match '2.5'
        if (min == Math.Truncate(min) && max == Math.Truncate(max))
        {
            return val == Math.Truncate(val);
        }

        return true;
    }

    #endregion
}");
    }
}
#endif
